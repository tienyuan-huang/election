# **選舉資料技術守則 (Data Technical Manual)**

版本：1.0  
最後更新：2024-07-25

## **1\. 總覽 (Overview)**

本文件旨在為「台灣選舉地理資訊系統」的前端開發提供一份清晰、標準化的資料使用指南。所有資料均由 r\_election\_data\_processing R 腳本生成，該腳本已將原始的中選會選舉資料清理、聚合，並轉換為適合網頁應用直接取用的格式。  
本守則的核心目標是確保開發者能夠：

* 準確理解資料的儲存結構與欄位意義。  
* 順利讀取指定年份與選舉類型的資料。  
* 透過標準化的 geo\_key 將選舉數據與地理圖資（GeoJSON）進行串接。  
* 實現村里層級的跨年度選舉數據比較功能。

## **2\. 檔案結構與命名規則 (File Structure & Naming Convention)**

所有處理完成的資料皆存放於 output/ 目錄下，並依照「年份」建立子資料夾。此結構化設計旨在讓前端應用能夠透過簡單的路徑規則動態讀取所需資料。

### **2.1 目錄結構**

output/  
├── 2024/  
│   ├── regional\_legislator\_votes.csv  
│   ├── regional\_legislator\_votes.rds  
│   ├── party\_votes.csv  
│   └── party\_votes.rds  
├── 2020/  
│   ├── regional\_legislator\_votes.csv  
│   ├── ...  
├── 2016/  
│   ├── ...  
└── 2012/  
    ├── ...

### **2.2 檔案說明**

| 檔案名稱 (Filename) | 說明 |
| :---- | :---- |
| regional\_legislator\_votes.csv | **區域立法委員選舉資料**。以「村里」為最小單位，記錄該村里內所有候選人的得票情形。 |
| party\_votes.csv | **不分區立委政黨票資料**。以「村里」為最小單位，記錄該村里內各政黨的得票情形。 |
| \*.rds | 為 R 語言專用的資料格式，內容與 .csv 相同，供後續 R 分析使用。前端開發請忽略此格式。 |

## **3\. 資料綱要 (Data Schema)**

所有 .csv 檔案均為 **UTF-8** 編碼。以下為兩種主要資料表的欄位定義。

### **3.1 區域立委 (regional\_legislator\_votes.csv)**

此資料表記錄了每一位候選人在每一個村里的得票詳細資訊。

| 欄位名稱 (Field Name) | 資料型態 (Data Type) | 說明 |
| :---- | :---- | :---- |
| geo\_key | String | **\[主鍵\]** 地理圖資串接碼。用於將此筆資料與地圖上的村里圖塊(Polygon)對應。詳見第 4 節。 |
| county\_name | String | 縣市名稱。例如："臺北市" |
| electoral\_district\_name | String | 選區名稱。例如："臺北市第01選區" |
| township\_name | String | 鄉鎮市區名稱。例如："北投區" |
| village\_name | String | 村里名稱。例如："建民里" |
| candidate\_no | Integer | 候選人號次。 |
| candidate\_name | String | 候選人姓名。 |
| party\_name | String | 候選人所屬政黨名稱。 |
| gender | String | 性別 (1: 男, 2: 女)。 |
| age | Integer | 年齡。 |
| incumbent | String | 是否為現任 (Y: 是, N: 否)。 |
| elected\_note | String | 當選註記 (\*: 當選, (空字串): 落選)。 |
| votes | Integer | **核心數據**：該候選人在該村里的得票數。 |
| vote\_percentage | Float | **核心數據**：該候選人在該村里的得票率 (%)。計算公式：votes / valid\_votes \* 100。 |
| valid\_votes | Integer | 該村里在該次選舉中的總有效票數。 |
| invalid\_votes | Integer | 該村里在該次選舉中的總無效票數。 |
| total\_votes | Integer | 該村里在該次選舉中的總投票數 (有效票 \+ 無效票)。 |
| electorate | Integer | 該村里在該次選舉中的選舉人數。 |
| turnout\_ratio | Float | 該村里在該次選舉中的投票率 (%)。計算公式：total\_votes / electorate \* 100。 |
| prov\_city...village | String | 原始地區代碼，供進階除錯或分析使用。 |

### **3.2 不分區政黨票 (party\_votes.csv)**

此資料表記錄了每一個政黨在每一個村里的得票詳細資訊。

| 欄位名稱 (Field Name) | 資料型態 (Data Type) | 說明 |
| :---- | :---- | :---- |
| geo\_key | String | **\[主鍵\]** 地理圖資串接碼。 |
| county\_name | String | 縣市名稱。 |
| township\_name | String | 鄉鎮市區名稱。 |
| village\_name | String | 村里名稱。 |
| party\_code | Integer | 政黨代號。 |
| party\_name | String | 政黨名稱。 |
| votes | Integer | **核心數據**：該政黨在該村里的得票數。 |
| vote\_percentage | Float | **核心數據**：該政黨在該村里的得票率 (%)。 |
| valid\_votes | Integer | 該村里在該次選舉中的總有效票數。 |
| invalid\_votes | Integer | 該村里在該次選舉中的總無效票數。 |
| total\_votes | Integer | 該村里在該次選舉中的總投票數。 |
| electorate | Integer | 該村里在該次選舉中的選舉人數。 |
| turnout\_ratio | Float | 該村里在該次選舉中的投票率 (%)。 |
| prov\_city...village | String | 原始地區代碼。 |

## **4\. 地理圖資串接碼 (geo\_key)**

geo\_key 是選舉資料與地理圖資（如 GeoJSON）之間最重要的橋樑。

* **唯一性**：一個 geo\_key 唯一對應一個村里行政區。  
* **一致性**：geo\_key 的生成規則在所有年份、所有選舉類型中保持一致，是實現跨年度比較的基礎。  
* 生成規則：geo\_key 由四個原始地區代碼拼接而成：  
  {prov\_city} \+ {county\_city} \+ {township} \+ {village 的末三碼}  
* **範例**：  
  * prov\_city: "63"  
  * county\_city: "000"  
  * township: "120"  
  * village: "0001"  
  * geo\_key \= "63000120001"

在前端應用中，您需要將村里圖資（GeoJSON）中的村里代碼（例如 VILLCODE）與本資料中的 geo\_key 進行匹配，以將選舉數據渲染到對應的地圖圖塊上。

## **5\. 網頁應用讀取策略 (Web Application Loading Strategy)**

前端應用應根據使用者選擇的「年份」和「選舉類型」動態地構建路徑來讀取資料。  
**範例：讀取 2020 年不分區政黨票資料 (使用 JavaScript Fetch API)**  
async function loadElectionData(year, type) {  
  // 1\. 根據使用者選擇，構建檔案路徑  
  // type 可以是 'regional\_legislator' 或 'party\_votes'  
  const filename \= (type \=== 'regional\_legislator')   
    ? 'regional\_legislator\_votes.csv'   
    : 'party\_votes.csv';  
      
  const dataUrl \= \`/output/${year}/${filename}\`;

  try {  
    // 2\. 發送請求並讀取 CSV 檔案  
    const response \= await fetch(dataUrl);  
    if (\!response.ok) {  
      throw new Error(\`Network response was not ok: ${response.statusText}\`);  
    }  
    const csvText \= await response.text();  
      
    // 3\. 解析 CSV 文字為 JSON 物件陣列 (建議使用 PapaParse 等函式庫)  
    // 以下為簡易手動解析範例  
    const lines \= csvText.trim().split('\\n');  
    const headers \= lines\[0\].split(',');  
    const data \= lines.slice(1).map(line \=\> {  
      const values \= line.split(',');  
      let entry \= {};  
      headers.forEach((header, i) \=\> {  
        entry\[header\] \= values\[i\];  
      });  
      return entry;  
    });

    console.log(\`成功讀取 ${year} 年 ${type} 資料:\`, data);  
    return data;

  } catch (error) {  
    console.error('讀取選舉資料失敗:', error);  
    return null;  
  }  
}

// 使用範例  
// loadElectionData(2020, 'party\_votes');

## **6\. 跨年度資料比較邏輯 (Cross-Year Comparison Logic)**

geo\_key 的一致性使得跨年度比較變得簡單直觀。當使用者在介面上選擇一個村里進行比較時，應執行以下步驟：

1. **識別 geo\_key**：從地圖互動中獲取使用者點擊的村里所對應的 geo\_key。  
2. **載入多年份資料**：非同步載入所有需要比較的年份與選舉類型的資料。例如，比較 2024 年和 2020 年的區域立委選舉。  
   const data2024 \= await loadElectionData(2024, 'regional\_legislator');  
   const data2020 \= await loadElectionData(2020, 'regional\_legislator');

3. **篩選與合併**：  
   * 分別在 data2024 和 data2020 中篩選出 geo\_key 與使用者選擇的 geo\_key 相符的所有記錄。  
   * 將篩選出的結果根據比較的維度（例如 party\_name 或 candidate\_name）進行整理。

**範例：比較某村里 (geo\_key: "63000120001") 中，中國國民黨與民主進步黨在 2024 與 2020 年的得票率**  
function compareVotePercentage(geoKey, data2024, data2020) {  
  const targetParties \= \['中國國民黨', '民主進步黨'\];

  // 篩選指定村里與政黨的資料  
  const villageData2024 \= data2024.filter(d \=\> d.geo\_key \=== geoKey && targetParties.includes(d.party\_name));  
  const villageData2020 \= data2020.filter(d \=\> d.geo\_key \=== geoKey && targetParties.includes(d.party\_name));

  // 建立一個易於比較的資料結構  
  const comparisonResult \= {};  
    
  villageData2024.forEach(d \=\> {  
    if (\!comparisonResult\[d.party\_name\]) comparisonResult\[d.party\_name\] \= {};  
    comparisonResult\[d.party\_name\]\['2024\_percentage'\] \= d.vote\_percentage;  
  });

  villageData2020.forEach(d \=\> {  
    if (\!comparisonResult\[d.party\_name\]) comparisonResult\[d.party\_name\] \= {};  
    comparisonResult\[d.party\_name\]\['2020\_percentage'\] \= d.vote\_percentage;  
  });  
    
  /\*  
   comparisonResult 的結果會像這樣：  
   {  
     "中國國民黨": {  
       "2024\_percentage": "45.12",  
       "2020\_percentage": "48.90"  
     },  
     "民主進步黨": {  
       "2024\_percentage": "51.30",  
       "2020\_percentage": "47.50"  
     }  
   }  
  \*/  
    
  // 將此結果用於渲染圖表或顯示在介面上  
  return comparisonResult;  
}

遵循本守則，即可確保前端開發工作流程順暢，並能打造出一個功能強大、數據準確的選舉地圖工具。